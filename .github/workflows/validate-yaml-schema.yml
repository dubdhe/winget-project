name: Validate WinGet Manifests (Per-File Schema)

# Expose the sleep interval (in minutes) as a variable
env:
  SLEEP_INTERVAL_MINUTES: ${{ vars.SLEEP_INTERVAL_MINUTES }}

on:
  pull_request: 
    types: [opened, synchronize, reopened]
    branches:
      - main
  workflow_dispatch:
    inputs:
      force_run:
        description: 'Force run even if no new files'
        required: false
        default: false
        type: boolean
      environment:
        description: 'Target environment'
        required: false
        default: 'dev'
        type: string

jobs:
  ### 1. Check for new installer files (runs first)
  check-changes:
    name: Check for newly added files
    runs-on: ubuntu-latest
    outputs:
      has_new_files: ${{ steps.check.outputs.has_new_files }}
      should_run: ${{ steps.setflag.outputs.should_run }}
      new_files: ${{ steps.check.outputs.new_files }}
    steps:
      - id: setflag
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" || "${{ github.ref }}" == "refs/heads/dev" ]]; then
            echo "should_run=true" >> "$GITHUB_OUTPUT"
          else
            echo "should_run=false" >> "$GITHUB_OUTPUT"
          fi
          
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Check for newly added installer files
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
          else
            BASE_SHA=$(git merge-base HEAD origin/main)
            HEAD_SHA=$(git rev-parse HEAD)
          fi
          
          echo "$BASE_SHA"
          echo "$HEAD_SHA"
          NEW_FILES=$(git diff --name-only --diff-filter=A "$BASE_SHA" "$HEAD_SHA" | grep 'manifests/.*\.installer\.yaml$' || true)
          
          if [[ -z "$NEW_FILES" ]]; then
            echo "has_new_files=false" >> "$GITHUB_OUTPUT"
            echo "‚ö†Ô∏è No new installer files detected - skipping pipeline"
          else
            echo "has_new_files=true" >> "$GITHUB_OUTPUT"
            echo "new_files<<EOF" >> "$GITHUB_OUTPUT"
            echo "$NEW_FILES" >> "$GITHUB_OUTPUT"
            echo "EOF" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Found new installer files: $NEW_FILES"
          fi

  ### 2. Validate changed manifests with Yamale
  validate:
    name: Validate manifests with yaml-ls-check
    runs-on: ubuntu-latest
    needs: check-changes
    if: needs.check-changes.outputs.should_run == 'true' && needs.check-changes.outputs.has_new_files == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Clean up manifests (remove $schema, fix ManifestType)
        run: |
          echo "üîß Cleaning up manifest YAML files..."

          echo "üîπ Removing any yaml-language-server $schema lines..."
          find manifests/ -name '*.yaml' -exec sed -i '/^# yaml-language-server: \$schema/d' {} +

          echo "üîπ Replacing ManifestType: locale ‚Üí defaultLocale where needed..."
          find manifests/ -name '*.locale.*.yaml' -exec sed -i 's/^ManifestType: locale/ManifestType: defaultLocale/' {} +

          echo "‚úÖ Manifest files cleaned"

      - name: Validate YAML against Winget schemas
        uses: InoUno/yaml-ls-check@develop
        with:
          root: .

  ### 3. Extract installer URLs into a matrix
  extract-installers:
    name: Extract Installers for Matrix
    #runs-on: [self-hosted, Linux, ARM64, winget]
    runs-on: ubuntu-latest
    needs: [check-changes, validate]
    if: needs.check-changes.outputs.should_run == 'true' && needs.check-changes.outputs.has_new_files == 'true'
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has_installers: ${{ steps.set-matrix.outputs.has_installers }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install yq & jq
        run: |
          curl -L https://github.com/mikefarah/yq/releases/download/v4.35.2/yq_linux_amd64 -o yq
          chmod +x yq && sudo mv yq /usr/local/bin/yq
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Build download matrix
        id: set-matrix
        run: |
          set -e
          echo "üîç Building download matrix..."
        
          CHANGED_FILES="${{ needs.check-changes.outputs.new_files }}"
          echo "üìÅ Changed files: $CHANGED_FILES"

          INSTALLERS=()
          for file in $CHANGED_FILES; do
            PACKAGE_ID=$(yq '.PackageIdentifier' "$file")
            PACKAGE_VERSION=$(yq '.PackageVersion' "$file")
            COUNT=$(yq '.Installers | length' "$file")

          for i in $(seq 0 $((COUNT - 1))); do
            ARCH=$(yq ".Installers[$i].Architecture" "$file")
            URL=$(yq ".Installers[$i].InstallerUrl" "$file")
            HASH=$(yq ".Installers[$i].InstallerSha256" "$file")

            if [[ -n "$URL" && -n "$HASH" ]]; then
              INSTALLERS+=("$(jq -nc \
                --arg id "$PACKAGE_ID" \
                --arg version "$PACKAGE_VERSION" \
                --arg arch "$ARCH" \
                --arg url "$URL" \
                --arg hash "$HASH" \
                '{id: $id, version: $version, arch: $arch, url: $url, hash: $hash}')")
            fi
          done
          done

          if [[ ${#INSTALLERS[@]} -eq 0 ]]; then
            echo 'matrix={"installer":[]}' >> "$GITHUB_OUTPUT"
            echo "has_installers=false" >> "$GITHUB_OUTPUT"
            echo "‚ö†Ô∏è No valid installers found in changed files."
          else
            JSON_ARRAY=$(printf "%s\n" "${INSTALLERS[@]}" | jq -s '[.[]] | unique_by(.id, .version, .arch)')
            MATRIX_JSON=$(jq -c <<< "{\"installer\":$JSON_ARRAY}")
            echo "matrix=$MATRIX_JSON" >> "$GITHUB_OUTPUT"
            echo "has_installers=true" >> "$GITHUB_OUTPUT"
            echo "‚úÖ Installer matrix built:"
            echo "$MATRIX_JSON"
          fi
          
  ### 4. Download,Upload & verify each installer
  process-installers:
    name: Handle Installers (${{ matrix.installer.id }} ${{ matrix.installer.arch }})
    #runs-on: [self-hosted, Linux, ARM64, winget]
    runs-on: ubuntu-latest
    needs: [check-changes, extract-installers]
    if: needs.check-changes.outputs.should_run == 'true' && needs.extract-installers.outputs.has_installers == 'true'
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.extract-installers.outputs.matrix) }}

    steps:
      - uses: actions/checkout@v4

      - name: Clean temp_download
        run: rm -rf temp_download && mkdir temp_download

      - name: Download installer
        run: |
          set -e
          ID="${{ matrix.installer.id }}"
          VER="${{ matrix.installer.version }}"
          ARCH="${{ matrix.installer.arch }}"
          URL="${{ matrix.installer.url }}"
          HASH_EXPECTED="${{ matrix.installer.hash }}"

          mkdir -p "temp_download/$ID/$VER/$ARCH"
          FILEPATH="temp_download/$ID/$VER/$ARCH/$(basename "$URL")"

          curl -L "$URL" -o "$FILEPATH"
          HASH_ACTUAL=$(sha256sum "$FILEPATH" | awk '{print toupper($1)}')

          if [[ "$HASH_ACTUAL" != "$HASH_EXPECTED" ]]; then
            echo "‚ùå Hash mismatch: $FILEPATH"
            exit 1
          fi
          echo "‚úÖ Downloaded and verified: $FILEPATH"

      # - name: Upload installer via FTP
      #   run: |
      #     set -e
      #     ID="${{ matrix.installer.id }}"
      #     VER="${{ matrix.installer.version }}"
      #     ARCH="${{ matrix.installer.arch }}"
      #     FILE_NAME=$(basename "${{ matrix.installer.url }}")
      #     FILEPATH="temp_download/$ID/$VER/$ARCH/$FILE_NAME"
      #     REMOTE_DIR="New Software/$ID/$VER/$ARCH"
      #     echo "üì§ Uploading $FILE_NAME to FTP at $TARGET_DIR"

      #     lftp -u "${{ secrets.FTP_USER }}","${{ secrets.FTP_PASS }}" ftp://${{ secrets.FTP_HOST }} <<EOF
      #     set ftp:passive-mode on
      #     set ssl:verify-certificate no
      #     mkdir -p "$REMOTE_DIR"
      #     cd "$REMOTE_DIR"
      #     put "$FILEPATH"
      #     bye
      #     EOF

      #     echo "‚úÖ Upload complete for: $FILE_NAME"
      # - name: Poll scan result
      #   run: |
      #     set -e
      #     FILE_NAME=$(basename "${{ matrix.installer.url }}")
      #     PACKAGE_DIR="${{ matrix.installer.id }}/${{ matrix.installer.version }}/${{ matrix.installer.arch }}"
      #     MAX_ATTEMPTS=18
      #     INTERVAL_MINUTES=${{ vars.SLEEP_INTERVAL_MINUTES }}

      #     echo "üïí Initial wait for ${INTERVAL_MINUTES} minutes before first check..."
      #     sleep $((INTERVAL_MINUTES * 60))

      #     for attempt in $(seq 1 $MAX_ATTEMPTS); do
      #       echo "üîÅ Poll Attempt #$attempt: Checking FTP for $PACKAGE_DIR/$FILE_NAME"
      #       OUTPUT=$(mktemp)
      #       lftp > "$OUTPUT" 2>&1 <<EOF
      #       open -u ${{ secrets.FTP_USER }},${{ secrets.FTP_PASS }} ftp://${{ secrets.FTP_HOST }}
      #       set ftp:passive-mode on
      #       set ssl:verify-certificate no
      #       cls -1 "Scanned software failed/${PACKAGE_DIR}" || echo "‚ö†Ô∏è Failed to list failed dir"
      #       cls -1 "Scanned software passed/${PACKAGE_DIR}" || echo "‚ö†Ô∏è Failed to list passed dir"
      #       bye
      #     EOF

      #       if grep "$FILE_NAME" "$OUTPUT" | grep "Scanned software failed"; then
      #         echo "‚ùå Found $FILE_NAME in failed folder"
      #         lftp <<EOF
      #         open -u ${{ secrets.FTP_USER }},${{ secrets.FTP_PASS }} ftp://${{ secrets.FTP_HOST }}
      #         set ftp:passive-mode on
      #         set ssl:verify-certificate no
      #         rm -r "Scanned software failed/${PACKAGE_DIR}"
      #     EOF
      #         exit 1
      #       fi

      #       if grep "$FILE_NAME" "$OUTPUT" | grep "Scanned software passed"; then
      #         echo "‚úÖ File passed scan: $FILE_NAME"
      #         lftp <<EOF
      #         open -u ${{ secrets.FTP_USER }},${{ secrets.FTP_PASS }} ftp://${{ secrets.FTP_HOST }}
      #         set ftp:passive-mode on
      #         set ssl:verify-certificate no
      #         rm -r "Scanned software passed/${PACKAGE_DIR}"
      #     EOF
      #         exit 0
      #       fi

      #       echo "üïí Not yet scanned. Sleeping ${INTERVAL_MINUTES} minutes..."
      #       sleep $((INTERVAL_MINUTES * 60))
      #     done

      #     echo "‚ùå Timeout: Scan result not found after $((MAX_ATTEMPTS * INTERVAL_MINUTES)) minutes"
      #     exit 1
